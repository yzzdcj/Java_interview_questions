####【角色设定】：我是你的架构师。
####【当前阶段】：电商大促核心链路压测。
####【业务背景】：
    我们有一个“爆款商品详情”接口。

    现状：某个 SKU（如 iPhone 15）访问量极高（QPS 5000+）。

    问题：缓存设置了 1 小时过期。当缓存过期的那一瞬间，5000 个请求同时涌入，发现 Redis 没数据，全部打向数据库，导致数据库连接池瞬间被占满，服务报警。

####【考核题目】：
    请分别用 方案 A（互斥锁） 和 方案 B（逻辑过期） 解决这个问题。

####⚔️ 挑战一：方案 A - 互斥锁 (强一致性)
    【原理】：当缓存失效时，不是所有线程都去查数据库，而是只有一个线程能抢到锁去查库，其他线程等待并重试。
    【适用场景】：数据一致性要求高（如金额、库存），允许短暂的等待。
    【具体需求】：
    在 ProductService 中编写 queryWithMutex(Long id) 方法。

    流程：

        查 Redis，命中则返回。

        未命中，尝试获取锁（Key: lock:sku:1001）。

        抢到锁：

            Double Check (双重检查)：再次查 Redis（防止别人已经重建好了）。如果有了，释放锁，返回。
    
            查数据库。
    
            写入 Redis（TTL 30分钟）。
    
            释放锁。

        没抢到锁：

            休眠 50ms。
    
            递归调用自己（重试）。

####🛡️ 挑战二：方案 B - 逻辑过期 (高可用性)
    【原理】： Redis 中的 Key 永不过期（TTL = -1）。但是我们在 Value 里面包了一层，手动记录一个“过期时间”。
    当线程发现“逻辑时间”已过期时：直接返回旧数据（保证接口不阻塞，响应快）。异步开启一个线程去查数据库并更新缓存（重置逻辑过期时间）。

    【适用场景】：注重用户体验，允许短暂的数据不一致（如商品名称、详情介绍）。

    【具体需求】：

        封装类 (RedisData)：

            我们需要一个包装类，里面包含两个字段：
    
            LocalDateTime expireTime (逻辑过期时间)。
            
            Object data (真实的商品数据)。

        请定义这个类。

        业务代码 (queryWithLogicalExpire)：

        查 Redis。
        
        未命中：返回 null（逻辑过期模式下，通常预热时会将热点数据全部加载，理论上不应该未命中，这里简化处理）。
        
        命中：
        
        判断 expireTime 是否过期。
            
            未过期：直接返回 data。
        
            已过期：
        
                尝试获取互斥锁（防止启动 100 个线程去重建）。
                
                    抢到锁：开启一个独立线程（利用线程池）去查库、更新 Redis（重置过期时间）、释放锁。
                
                    没抢到锁：不要等待！ 直接返回当前的旧数据 data。
                
                    主线程：无论有没有抢到锁，都直接返回当前的旧数据 data。

###请提供：

    RedisData 包装类的代码。

    ProductService 中 queryWithMutex 和 queryWithLogicalExpire 两个方法的实现。