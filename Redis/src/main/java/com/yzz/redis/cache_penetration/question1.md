####【考核题目】：
    分别使用 “缓存空对象” 和 “布隆过滤器” 两种方案解决商品详情页的缓存穿透问题。

####【业务背景】：
    我们负责电商平台的“商品详情查询接口”。

    现状：数据库有 1000 万个商品。

    攻击：最近监控发现，有大量请求查询 id > 10000000 的商品，数据库 CPU 飙升到 90%。

    技术栈：Spring Boot + StringRedisTemplate + Redisson。

####⚔️ 挑战一：方案 A - 缓存空对象 (Basic)
    这是最简单、成本最低的方案，适合数据量不大、或者攻击的 Key 重复率较高的场景。

####【具体需求】：
    编写 ProductService.getProductById(Long id)。

    流程：

        查 Redis，命中则返回。

            关键点：如果命中到的是“空标识”（比如空字符串 ""），直接返回 null，不再查库。

        查数据库。

            关键点：如果数据库也没查到，向 Redis 写入一个空字符串。

        核心考点：写入空对象时，必须设置一个较短的 TTL（比如 5 分钟）。为什么？（防止长期占用内存，且万一后来数据库真的加了这个商品，缓存能及时过期）。

####请提供：方案 A 的代码实现。

####🛡️ 挑战二：方案 B - 布隆过滤器 (Advanced)
    这是处理海量随机 Key 攻击的终极方案。

####【具体需求】：
    利用 Redisson 的 RBloomFilter。

    初始化（口述或伪代码）：

        假设在系统启动时，已经把 1000 万个商品 ID 加载到了布隆过滤器中。

        预计插入 1000 万，误判率 0.01。

    业务逻辑 (ProductService.getProductByIdWithBloom)：

        第一道防线：请求进来，先问布隆过滤器 contains(id)。

            逻辑：
    
                如果布隆过滤器说**“不存在”**：直接返回 null（保护 Redis 和 DB）。
    
                如果布隆过滤器说**“存在”**（可能是真存在，也可能是误判）：继续走“查 Redis -> 查 DB”的流程。

####请提供：方案 B 的代码实现（注入 RBloomFilter）。