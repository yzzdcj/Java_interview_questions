####【考核题目】：
    针对 “百亿级流量电商平台”，设计 Redis 的 内存淘汰策略 与 过期删除优化 方案。

####【业务背景】：
    我们的 Redis 集群内存非常紧张（每台机器 32GB，已用 90%）。
    业务场景分为两类数据，存储在不同的 Redis 实例中（或通过 Key 前缀区分）：

    场景 A（商品缓存）：存储 product:1001 详情。数据来自数据库，可重建。访问模式符合“二八定律”（20% 的热点商品占据 80% 的流量）。

    场景 B（用户会话/验证码）：存储 session:token 或 sms:code。数据不可重建（丢了用户就得重新登录），且每个 Key 必须设置 TTL。

####【具体需求】：

    内存淘汰策略选型 (maxmemory-policy)：

        针对 场景 A（商品缓存），你会选择哪种淘汰策略？为什么？（allkeys-lru vs allkeys-lfu vs volatile-lru）。

        针对 场景 B（会话数据），你会选择哪种淘汰策略？如果内存满了，是随机删，还是删快过期的？

    内部过期原理 (面试必问)：

        请简述 Redis 是如何发现一个 Key 过期的？（惰性删除 + 定期删除）。

        追问：如果 Redis 里的 Key 都是 1 小时后过期，为什么 1 小时过去了，内存并没有完全释放？

        大 Key 删除灾难 (Lazy Free)：

            事故：有一个存了 500 万元素的 List 突然过期了，或者被淘汰策略选中了。Redis 瞬间卡顿了 2 秒，导致后续请求超时。

            解决：如何配置 Redis 让他 “异步” 删除这些大 Key，不阻塞主线程？（Redis 4.0+ 新特性）。

####请提供：

    场景 A 和 场景 B 对应的 redis.conf 配置项。

    简短解释 Redis 的“定期删除”机制。

    开启“异步删除”的配置项。

####💡 提示（解题关键）
    LRU (最近最少使用) vs LFU (最不经常使用/访问频率最低)。

    allkeys (所有键) vs volatile (只针对设置了 TTL 的键)。

    unlink 命令。